// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: achievements.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAchievement = `-- name: CreateAchievement :one
insert into achievement (comment, attachment_link, user_uuid, status_uuid)
values ($1, $2, $3,
        (select s.uuid from status s where s.internal_value = 'unapproved' and s.type = 'achievement_status'))
returning uuid
`

type CreateAchievementParams struct {
	Comment        pgtype.Text
	AttachmentLink string
	UserUuid       pgtype.UUID
}

func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createAchievement, arg.Comment, arg.AttachmentLink, arg.UserUuid)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const deleteAchievementCategoryValueByAchievementUUID = `-- name: DeleteAchievementCategoryValueByAchievementUUID :exec
delete
from achievement_category_value
where achievement_uuid = $1
`

func (q *Queries) DeleteAchievementCategoryValueByAchievementUUID(ctx context.Context, achievementUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAchievementCategoryValueByAchievementUUID, achievementUuid)
	return err
}

const getAchievementSubCategories = `-- name: GetAchievementSubCategories :many
select distinct c.uuid, c.name, cv.name as selected_value, cv.point, av_cv.name as available_value
from category c
         join achievement_category ac on ac.category_uuid = c.uuid
         join achievement_category_value acv on acv.achievement_uuid = ac.achievement_uuid
         join category_value cv on cv.uuid = acv.category_value_uuid and cv.category_uuid = c.uuid
         join category_value av_cv on av_cv.category_uuid = c.uuid
where parent_category is not null
  and ac.achievement_uuid = $1
`

type GetAchievementSubCategoriesRow struct {
	Uuid           pgtype.UUID
	Name           string
	SelectedValue  string
	Point          pgtype.Numeric
	AvailableValue string
}

func (q *Queries) GetAchievementSubCategories(ctx context.Context, achievementUuid pgtype.UUID) ([]GetAchievementSubCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getAchievementSubCategories, achievementUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchievementSubCategoriesRow
	for rows.Next() {
		var i GetAchievementSubCategoriesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.SelectedValue,
			&i.Point,
			&i.AvailableValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimpleUserAchievementByUUID = `-- name: GetSimpleUserAchievementByUUID :one
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, a.achievement_date,
       c.name                         as category_name,
       s.display_value                as status,
       c.uuid                         as category_uuid,
       c.point_amount                 as base_point_amount,
       coalesce(sum(cv.point) + c.point_amount, 0)::numeric as point_amount,
       count(*) over ()               as total_records
from achievement a
         join achievement_category ac on ac.achievement_uuid = a.uuid
         left join category c on c.uuid = ac.category_uuid and parent_category is null
         left join category c_p on c_p.uuid = ac.category_uuid and c_p.parent_category is not null
         join achievement_category_value acv on acv.achievement_uuid = a.uuid
         join category_value cv on cv.uuid = acv.category_value_uuid and cv.category_uuid = c.uuid
         join status s on s.uuid = a.status_uuid
where a.uuid = $1
  and c.uuid is not null
group by c.name, a.uuid, a.comment, c.point_amount, c.uuid, attachment_link, a.user_uuid, a.status_uuid,
         s.display_value
`

type GetSimpleUserAchievementByUUIDRow struct {
	Uuid            pgtype.UUID
	Comment         pgtype.Text
	AttachmentLink  string
	UserUuid        pgtype.UUID
	StatusUuid      pgtype.UUID
	AchievementDate pgtype.Date
	CategoryName    pgtype.Text
	Status          pgtype.Text
	CategoryUuid    pgtype.UUID
	BasePointAmount pgtype.Numeric
	PointAmount     pgtype.Numeric
	TotalRecords    int64
}

func (q *Queries) GetSimpleUserAchievementByUUID(ctx context.Context, uuid pgtype.UUID) (GetSimpleUserAchievementByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getSimpleUserAchievementByUUID, uuid)
	var i GetSimpleUserAchievementByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Comment,
		&i.AttachmentLink,
		&i.UserUuid,
		&i.StatusUuid,
		&i.AchievementDate,
		&i.CategoryName,
		&i.Status,
		&i.CategoryUuid,
		&i.BasePointAmount,
		&i.PointAmount,
		&i.TotalRecords,
	)
	return i, err
}

const getUserAchievements = `-- name: GetUserAchievements :many
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, a.achievement_date,
       c.name                         as category_name,
       s.display_value                as status,
       c.uuid                         as category_uuid,
       coalesce(sum(cv.point) + c.point_amount, 0)::numeric as point_amount,
       count(*) over ()               as total_records
from achievement a
         join achievement_category ac on ac.achievement_uuid = a.uuid
         left join category c on c.uuid = ac.category_uuid and parent_category is null
         left join category c_p on c_p.uuid = ac.category_uuid and c_p.parent_category is not null
         join achievement_category_value acv on acv.achievement_uuid = a.uuid
         join category_value cv on cv.uuid = acv.category_value_uuid and cv.category_uuid = c.uuid
         join status s on s.uuid = a.status_uuid
where a.user_uuid = $1
  and s.internal_value != 'removed'
  and c.uuid is not null
group by c.name, a.uuid, a.comment, c.point_amount, c.uuid, attachment_link, a.user_uuid, a.status_uuid,
         s.display_value
`

type GetUserAchievementsRow struct {
	Uuid            pgtype.UUID
	Comment         pgtype.Text
	AttachmentLink  string
	UserUuid        pgtype.UUID
	StatusUuid      pgtype.UUID
	AchievementDate pgtype.Date
	CategoryName    pgtype.Text
	Status          pgtype.Text
	CategoryUuid    pgtype.UUID
	PointAmount     pgtype.Numeric
	TotalRecords    int64
}

func (q *Queries) GetUserAchievements(ctx context.Context, userUuid pgtype.UUID) ([]GetUserAchievementsRow, error) {
	rows, err := q.db.Query(ctx, getUserAchievements, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAchievementsRow
	for rows.Next() {
		var i GetUserAchievementsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Comment,
			&i.AttachmentLink,
			&i.UserUuid,
			&i.StatusUuid,
			&i.AchievementDate,
			&i.CategoryName,
			&i.Status,
			&i.CategoryUuid,
			&i.PointAmount,
			&i.TotalRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAchievementsWithPagination = `-- name: GetUserAchievementsWithPagination :many
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, a.achievement_date,
       c.name                         as category_name,
       s.display_value                as status,
       c.uuid                         as category_uuid,
       coalesce(sum(cv.point) + c.point_amount, 0)::numeric as point_amount,
       count(*) over ()               as total_records
from achievement a
         join achievement_category ac on ac.achievement_uuid = a.uuid
         left join category c on c.uuid = ac.category_uuid and parent_category is null
         left join category c_p on c_p.uuid = ac.category_uuid and c_p.parent_category is not null
         join achievement_category_value acv on acv.achievement_uuid = a.uuid
         join category_value cv on cv.uuid = acv.category_value_uuid  and cv.category_uuid = c.uuid
         join status s on s.uuid = a.status_uuid
where a.user_uuid = $1
  and c.uuid is not null
group by c.name, a.uuid, a.comment, c.point_amount, c.uuid, attachment_link, a.user_uuid, a.status_uuid,
         s.display_value
limit $2 offset $3
`

type GetUserAchievementsWithPaginationParams struct {
	UserUuid pgtype.UUID
	Limit    int32
	Offset   int32
}

type GetUserAchievementsWithPaginationRow struct {
	Uuid            pgtype.UUID
	Comment         pgtype.Text
	AttachmentLink  string
	UserUuid        pgtype.UUID
	StatusUuid      pgtype.UUID
	AchievementDate pgtype.Date
	CategoryName    pgtype.Text
	Status          pgtype.Text
	CategoryUuid    pgtype.UUID
	PointAmount     pgtype.Numeric
	TotalRecords    int64
}

func (q *Queries) GetUserAchievementsWithPagination(ctx context.Context, arg GetUserAchievementsWithPaginationParams) ([]GetUserAchievementsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getUserAchievementsWithPagination, arg.UserUuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAchievementsWithPaginationRow
	for rows.Next() {
		var i GetUserAchievementsWithPaginationRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Comment,
			&i.AttachmentLink,
			&i.UserUuid,
			&i.StatusUuid,
			&i.AchievementDate,
			&i.CategoryName,
			&i.Status,
			&i.CategoryUuid,
			&i.PointAmount,
			&i.TotalRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeAchievementApproved = `-- name: MakeAchievementApproved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'approved' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementApproved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementApproved, uuid)
	return err
}

const makeAchievementDeclined = `-- name: MakeAchievementDeclined :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'declined' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementDeclined(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementDeclined, uuid)
	return err
}

const makeAchievementRemoved = `-- name: MakeAchievementRemoved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'removed' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementRemoved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementRemoved, uuid)
	return err
}

const makeAchievementUnapproved = `-- name: MakeAchievementUnapproved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'unapproved' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementUnapproved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementUnapproved, uuid)
	return err
}

const makeAchievementUsed = `-- name: MakeAchievementUsed :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'used' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementUsed(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementUsed, uuid)
	return err
}

const removeAllAchievementCategory = `-- name: RemoveAllAchievementCategory :exec
delete
from achievement_category
where achievement_uuid = $1
`

func (q *Queries) RemoveAllAchievementCategory(ctx context.Context, achievementUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllAchievementCategory, achievementUuid)
	return err
}

const updateAchievement = `-- name: UpdateAchievement :exec
update achievement
set comment         = $1,
    attachment_link = $2
where uuid = $3
`

type UpdateAchievementParams struct {
	Comment        pgtype.Text
	AttachmentLink string
	Uuid           pgtype.UUID
}

func (q *Queries) UpdateAchievement(ctx context.Context, arg UpdateAchievementParams) error {
	_, err := q.db.Exec(ctx, updateAchievement, arg.Comment, arg.AttachmentLink, arg.Uuid)
	return err
}

const updateAchievementWithStatus = `-- name: UpdateAchievementWithStatus :exec
update achievement a
set comment         = $1,
    attachment_link = $2,
    status_uuid = (select s.uuid from status s where s.internal_value = 'unapproved' and s.type = 'achievement_status')
where a.uuid = $3
`

type UpdateAchievementWithStatusParams struct {
	Comment        pgtype.Text
	AttachmentLink string
	Uuid           pgtype.UUID
}

func (q *Queries) UpdateAchievementWithStatus(ctx context.Context, arg UpdateAchievementWithStatusParams) error {
	_, err := q.db.Exec(ctx, updateAchievementWithStatus, arg.Comment, arg.AttachmentLink, arg.Uuid)
	return err
}
