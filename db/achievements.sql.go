// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: achievements.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAchievement = `-- name: CreateAchievement :one
insert into achievement (comment, attachment_link, user_uuid, status_uuid)
values ($1, $2, $3, (select s.uuid from status s where s.internal_value = 'unapproved' and s.type = 'achievement_status'))
    returning uuid
`

type CreateAchievementParams struct {
	Comment        pgtype.Text
	AttachmentLink string
	UserUuid       pgtype.UUID
}

func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createAchievement, arg.Comment, arg.AttachmentLink, arg.UserUuid)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getSimpleUserAchievementByUUID = `-- name: GetSimpleUserAchievementByUUID :one
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, c.name as category_name, s.display_value as status, sum(c_p.point_amount) as point_amount
from achievement a
         join user_achievement ua on a.uuid = ua.achievement_uuid
         join achievement_category ac on ac.achievement_uuid = a.uuid
         join category c on c.uuid = ac.category_uuid and parent_category is null
         join category c_p on c.uuid = ac.category_uuid
         join status s on s.uuid = a.status_uuid
where a.uuid = $1
group by c.name, a.uuid, a.comment, attachment_link, a.user_uuid, a.status_uuid, s.display_value
`

type GetSimpleUserAchievementByUUIDRow struct {
	Uuid           pgtype.UUID
	Comment        pgtype.Text
	AttachmentLink string
	UserUuid       pgtype.UUID
	StatusUuid     pgtype.UUID
	CategoryName   string
	Status         pgtype.Text
	PointAmount    int64
}

func (q *Queries) GetSimpleUserAchievementByUUID(ctx context.Context, uuid pgtype.UUID) (GetSimpleUserAchievementByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getSimpleUserAchievementByUUID, uuid)
	var i GetSimpleUserAchievementByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Comment,
		&i.AttachmentLink,
		&i.UserUuid,
		&i.StatusUuid,
		&i.CategoryName,
		&i.Status,
		&i.PointAmount,
	)
	return i, err
}

const getUserAchievements = `-- name: GetUserAchievements :many
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, c.name as category_name, s.display_value as status, sum(c_p.point_amount) as point_amount
from achievement a
         join user_achievement ua on a.uuid = ua.achievement_uuid
         join achievement_category ac on ac.achievement_uuid = a.uuid
         join category c on c.uuid = ac.category_uuid and parent_category is null
         join category c_p on c.uuid = ac.category_uuid
         join status s on s.uuid = a.status_uuid
where a.user_uuid = $1
group by c.name, a.uuid, a.comment, attachment_link, a.user_uuid, a.status_uuid, s.display_value
`

type GetUserAchievementsRow struct {
	Uuid           pgtype.UUID
	Comment        pgtype.Text
	AttachmentLink string
	UserUuid       pgtype.UUID
	StatusUuid     pgtype.UUID
	CategoryName   string
	Status         pgtype.Text
	PointAmount    int64
}

func (q *Queries) GetUserAchievements(ctx context.Context, userUuid pgtype.UUID) ([]GetUserAchievementsRow, error) {
	rows, err := q.db.Query(ctx, getUserAchievements, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAchievementsRow
	for rows.Next() {
		var i GetUserAchievementsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Comment,
			&i.AttachmentLink,
			&i.UserUuid,
			&i.StatusUuid,
			&i.CategoryName,
			&i.Status,
			&i.PointAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAchievementsWithPagination = `-- name: GetUserAchievementsWithPagination :many
select a.uuid, a.comment, a.attachment_link, a.user_uuid, a.status_uuid, c.name as category_name, s.display_value as status, sum(c_p.point_amount) as point_amount, count(*) over() as total_records
from achievement a
         join user_achievement ua on a.uuid = ua.achievement_uuid
         join achievement_category ac on ac.achievement_uuid = a.uuid
         join category c on c.uuid = ac.category_uuid and parent_category is null
         join category c_p on c.uuid = ac.category_uuid
         join status s on s.uuid = a.status_uuid
where a.user_uuid = $1
group by c.name, a.uuid, a.comment, attachment_link, a.user_uuid, a.status_uuid, s.display_value
    limit $2 offset $3
`

type GetUserAchievementsWithPaginationParams struct {
	UserUuid pgtype.UUID
	Limit    int32
	Offset   int32
}

type GetUserAchievementsWithPaginationRow struct {
	Uuid           pgtype.UUID
	Comment        pgtype.Text
	AttachmentLink string
	UserUuid       pgtype.UUID
	StatusUuid     pgtype.UUID
	CategoryName   string
	Status         pgtype.Text
	PointAmount    int64
	TotalRecords   int64
}

func (q *Queries) GetUserAchievementsWithPagination(ctx context.Context, arg GetUserAchievementsWithPaginationParams) ([]GetUserAchievementsWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getUserAchievementsWithPagination, arg.UserUuid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAchievementsWithPaginationRow
	for rows.Next() {
		var i GetUserAchievementsWithPaginationRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Comment,
			&i.AttachmentLink,
			&i.UserUuid,
			&i.StatusUuid,
			&i.CategoryName,
			&i.Status,
			&i.PointAmount,
			&i.TotalRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeAchievementApproved = `-- name: MakeAchievementApproved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'approved' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementApproved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementApproved, uuid)
	return err
}

const makeAchievementDeclined = `-- name: MakeAchievementDeclined :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'declined' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementDeclined(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementDeclined, uuid)
	return err
}

const makeAchievementRemoved = `-- name: MakeAchievementRemoved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'removed' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementRemoved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementRemoved, uuid)
	return err
}

const makeAchievementUnapproved = `-- name: MakeAchievementUnapproved :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'unapproved' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementUnapproved(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementUnapproved, uuid)
	return err
}

const makeAchievementUsed = `-- name: MakeAchievementUsed :exec
update achievement
set status_uuid = (select status.uuid from status where internal_value = 'used' and type = 'achievement_status')
where achievement.uuid = $1
`

func (q *Queries) MakeAchievementUsed(ctx context.Context, uuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, makeAchievementUsed, uuid)
	return err
}

const removeAllAchievementCategory = `-- name: RemoveAllAchievementCategory :exec
delete
from achievement_category
where achievement_uuid = $1
`

func (q *Queries) RemoveAllAchievementCategory(ctx context.Context, achievementUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllAchievementCategory, achievementUuid)
	return err
}

const updateAchievement = `-- name: UpdateAchievement :exec
update achievement
set comment         = $1,
    attachment_link = $2
where uuid = $3
`

type UpdateAchievementParams struct {
	Comment        pgtype.Text
	AttachmentLink string
	Uuid           pgtype.UUID
}

func (q *Queries) UpdateAchievement(ctx context.Context, arg UpdateAchievementParams) error {
	_, err := q.db.Exec(ctx, updateAchievement, arg.Comment, arg.AttachmentLink, arg.Uuid)
	return err
}
