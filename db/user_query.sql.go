// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
insert into sys_user(name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, password, salt)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning uuid
`

type CreateUserParams struct {
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	Password        pgtype.Text
	Salt            pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.GradebookNumber,
		arg.BirthDate,
		arg.Email,
		arg.PhoneNumber,
		arg.Password,
		arg.Salt,
	)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getApprovedUserByGradeBookNumber = `-- name: GetApprovedUserByGradeBookNumber :one
select u.uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt, s.uuid, internal_value, display_value, type from sys_user u
                  join status s on u.status_uuid = s.uuid and s.type = 'user_status'
where u.gradebook_number = $1 and s.internal_value = 'approved'
`

type GetApprovedUserByGradeBookNumberRow struct {
	Uuid            pgtype.UUID
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	StatusUuid      pgtype.UUID
	Password        pgtype.Text
	Salt            pgtype.Text
	Uuid_2          pgtype.UUID
	InternalValue   pgtype.Text
	DisplayValue    pgtype.Text
	Type            pgtype.Text
}

func (q *Queries) GetApprovedUserByGradeBookNumber(ctx context.Context, gradebookNumber string) (GetApprovedUserByGradeBookNumberRow, error) {
	row := q.db.QueryRow(ctx, getApprovedUserByGradeBookNumber, gradebookNumber)
	var i GetApprovedUserByGradeBookNumberRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.SecondName,
		&i.Patronymic,
		&i.GradebookNumber,
		&i.BirthDate,
		&i.Email,
		&i.PhoneNumber,
		&i.StatusUuid,
		&i.Password,
		&i.Salt,
		&i.Uuid_2,
		&i.InternalValue,
		&i.DisplayValue,
		&i.Type,
	)
	return i, err
}

const getSimpleUserByUUID = `-- name: GetSimpleUserByUUID :one
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt
from sys_user
where uuid = $1
`

func (q *Queries) GetSimpleUserByUUID(ctx context.Context, uuid pgtype.UUID) (SysUser, error) {
	row := q.db.QueryRow(ctx, getSimpleUserByUUID, uuid)
	var i SysUser
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.SecondName,
		&i.Patronymic,
		&i.GradebookNumber,
		&i.BirthDate,
		&i.Email,
		&i.PhoneNumber,
		&i.StatusUuid,
		&i.Password,
		&i.Salt,
	)
	return i, err
}

const getSimpleUserList = `-- name: GetSimpleUserList :many
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt
from sys_user
`

func (q *Queries) GetSimpleUserList(ctx context.Context) ([]SysUser, error) {
	rows, err := q.db.Query(ctx, getSimpleUserList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SysUser
	for rows.Next() {
		var i SysUser
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.SecondName,
			&i.Patronymic,
			&i.GradebookNumber,
			&i.BirthDate,
			&i.Email,
			&i.PhoneNumber,
			&i.StatusUuid,
			&i.Password,
			&i.Salt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimpleUserListWithPagination = `-- name: GetSimpleUserListWithPagination :many
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt, count(*) over() as total_amount
from sys_user
limit $1 offset $2
`

type GetSimpleUserListWithPaginationParams struct {
	Limit  int32
	Offset int32
}

type GetSimpleUserListWithPaginationRow struct {
	Uuid            pgtype.UUID
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	StatusUuid      pgtype.UUID
	Password        pgtype.Text
	Salt            pgtype.Text
	TotalAmount     int64
}

func (q *Queries) GetSimpleUserListWithPagination(ctx context.Context, arg GetSimpleUserListWithPaginationParams) ([]GetSimpleUserListWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getSimpleUserListWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimpleUserListWithPaginationRow
	for rows.Next() {
		var i GetSimpleUserListWithPaginationRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.SecondName,
			&i.Patronymic,
			&i.GradebookNumber,
			&i.BirthDate,
			&i.Email,
			&i.PhoneNumber,
			&i.StatusUuid,
			&i.Password,
			&i.Salt,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserInfoWithGradeBook = `-- name: UpdateUserInfoWithGradeBook :exec
update sys_user
set name             = $1,
    second_name      = $2,
    patronymic       = $3,
    birth_date       = $4,
    phone_number     = $5,
    email            = $6,
    gradebook_number = $7,
    status_uuid      = (select status.uuid from status where internal_value = 'unapproved' and type = 'user_status')
where sys_user.uuid = $8
`

type UpdateUserInfoWithGradeBookParams struct {
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	BirthDate       pgtype.Date
	PhoneNumber     pgtype.Text
	Email           pgtype.Text
	GradebookNumber string
	Uuid            pgtype.UUID
}

func (q *Queries) UpdateUserInfoWithGradeBook(ctx context.Context, arg UpdateUserInfoWithGradeBookParams) error {
	_, err := q.db.Exec(ctx, updateUserInfoWithGradeBook,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.BirthDate,
		arg.PhoneNumber,
		arg.Email,
		arg.GradebookNumber,
		arg.Uuid,
	)
	return err
}

const updateUserInfoWithoutGradeBook = `-- name: UpdateUserInfoWithoutGradeBook :exec
update sys_user
set name         = $1,
    second_name  = $2,
    patronymic   = $3,
    birth_date   = $4,
    phone_number = $5,
    email        = $6
where uuid = $7
`

type UpdateUserInfoWithoutGradeBookParams struct {
	Name        string
	SecondName  string
	Patronymic  pgtype.Text
	BirthDate   pgtype.Date
	PhoneNumber pgtype.Text
	Email       pgtype.Text
	Uuid        pgtype.UUID
}

func (q *Queries) UpdateUserInfoWithoutGradeBook(ctx context.Context, arg UpdateUserInfoWithoutGradeBookParams) error {
	_, err := q.db.Exec(ctx, updateUserInfoWithoutGradeBook,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.BirthDate,
		arg.PhoneNumber,
		arg.Email,
		arg.Uuid,
	)
	return err
}
