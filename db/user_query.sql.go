// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
insert into sys_user(name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, password, salt)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning uuid
`

type CreateUserParams struct {
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	Password        pgtype.Text
	Salt            pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.GradebookNumber,
		arg.BirthDate,
		arg.Email,
		arg.PhoneNumber,
		arg.Password,
		arg.Salt,
	)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getApprovedUserByGradeBookNumber = `-- name: GetApprovedUserByGradeBookNumber :one
select u.uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt, s.uuid, internal_value, display_value, type from sys_user u
                  join status s on u.status_uuid = s.uuid and s.type = 'user_status'
where u.gradebook_number = $1 and s.internal_value = 'approved'
`

type GetApprovedUserByGradeBookNumberRow struct {
	Uuid            pgtype.UUID
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	StatusUuid      pgtype.UUID
	Password        pgtype.Text
	Salt            pgtype.Text
	Uuid_2          pgtype.UUID
	InternalValue   pgtype.Text
	DisplayValue    pgtype.Text
	Type            pgtype.Text
}

func (q *Queries) GetApprovedUserByGradeBookNumber(ctx context.Context, gradebookNumber string) (GetApprovedUserByGradeBookNumberRow, error) {
	row := q.db.QueryRow(ctx, getApprovedUserByGradeBookNumber, gradebookNumber)
	var i GetApprovedUserByGradeBookNumberRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.SecondName,
		&i.Patronymic,
		&i.GradebookNumber,
		&i.BirthDate,
		&i.Email,
		&i.PhoneNumber,
		&i.StatusUuid,
		&i.Password,
		&i.Salt,
		&i.Uuid_2,
		&i.InternalValue,
		&i.DisplayValue,
		&i.Type,
	)
	return i, err
}

const getShortRatingInfo = `-- name: GetShortRatingInfo :many
with sub as (select distinct row_number() over ()           as position,
                             u.uuid,
                             u.name,
                             second_name,
                             patronymic,
                             gradebook_number,
                             birth_date,
                             phone_number,
                             email,
                             u_s.display_value              as user_status,
                             sum(cv.point) + c.point_amount as point_amount,
                             count(a.uuid)                  as achievement_amount,
                             count(*) over ()               as total_amount,
                             case
                                 when max(case when a_s.internal_value = 'unapproved' then 1 else 0 end) = 1
                                     then false
                                 else true
                                 end                        as all_achievement_verified
             from sys_user u
                      left join achievement a on a.user_uuid = u.uuid and a.status_uuid in (select s.uuid
                                                                                            from status s
                                                                                            where s.type = 'achievement_status'
                                                                                              and s.internal_value != 'declined')
                      left join achievement_category ac on ac.achievement_uuid = a.uuid
                      left join category c
                                on c.uuid = ac.category_uuid and parent_category is null and
                                   c.status_uuid in (select s.uuid
                                                     from status s
                                                     where s.type = 'category_status'
                                                       and s.internal_value = 'active')
                      left join category c_p on c_p.uuid = ac.category_uuid and c_p.parent_category is not null and
                                                c_p.status_uuid in (select s.uuid
                                                                    from status s
                                                                    where s.type = 'category_status'
                                                                      and s.internal_value = 'active')
                      left join achievement_category_value acv on acv.achievement_uuid = a.uuid
                      left join category_value cv on cv.uuid = acv.category_value_uuid
                      left join status u_s on u_s.uuid = u.status_uuid and u_s.type = 'user_status'
                      left join status a_s on a_s.uuid = a.status_uuid and a_s.type = 'achievement_status'
             where c.point_amount is not null
             group by u.uuid, u.name, second_name, patronymic, gradebook_number, birth_date, phone_number, email,
                      c.point_amount, u_s.display_value

             order by c.point_amount)
select s.position,
       s.uuid,
       s.name,
       s.second_name,
       s.patronymic,
       s.gradebook_number,
       s.birth_date,
       s.phone_number,
       s.email,
       s.user_status,
       s.point_amount,
       s.achievement_amount,
       s.total_amount,
       s.all_achievement_verified
from sub s
where s.uuid = $1
   or s.position = 1
order by position
`

type GetShortRatingInfoRow struct {
	Position               int64
	Uuid                   pgtype.UUID
	Name                   string
	SecondName             string
	Patronymic             pgtype.Text
	GradebookNumber        string
	BirthDate              pgtype.Date
	PhoneNumber            pgtype.Text
	Email                  pgtype.Text
	UserStatus             pgtype.Text
	PointAmount            int32
	AchievementAmount      int64
	TotalAmount            int64
	AllAchievementVerified bool
}

func (q *Queries) GetShortRatingInfo(ctx context.Context, uuid pgtype.UUID) ([]GetShortRatingInfoRow, error) {
	rows, err := q.db.Query(ctx, getShortRatingInfo, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShortRatingInfoRow
	for rows.Next() {
		var i GetShortRatingInfoRow
		if err := rows.Scan(
			&i.Position,
			&i.Uuid,
			&i.Name,
			&i.SecondName,
			&i.Patronymic,
			&i.GradebookNumber,
			&i.BirthDate,
			&i.PhoneNumber,
			&i.Email,
			&i.UserStatus,
			&i.PointAmount,
			&i.AchievementAmount,
			&i.TotalAmount,
			&i.AllAchievementVerified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimpleUserByUUID = `-- name: GetSimpleUserByUUID :one
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt
from sys_user
where uuid = $1
`

func (q *Queries) GetSimpleUserByUUID(ctx context.Context, uuid pgtype.UUID) (SysUser, error) {
	row := q.db.QueryRow(ctx, getSimpleUserByUUID, uuid)
	var i SysUser
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.SecondName,
		&i.Patronymic,
		&i.GradebookNumber,
		&i.BirthDate,
		&i.Email,
		&i.PhoneNumber,
		&i.StatusUuid,
		&i.Password,
		&i.Salt,
	)
	return i, err
}

const getSimpleUserList = `-- name: GetSimpleUserList :many
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt
from sys_user
`

func (q *Queries) GetSimpleUserList(ctx context.Context) ([]SysUser, error) {
	rows, err := q.db.Query(ctx, getSimpleUserList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SysUser
	for rows.Next() {
		var i SysUser
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.SecondName,
			&i.Patronymic,
			&i.GradebookNumber,
			&i.BirthDate,
			&i.Email,
			&i.PhoneNumber,
			&i.StatusUuid,
			&i.Password,
			&i.Salt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimpleUserListWithPagination = `-- name: GetSimpleUserListWithPagination :many
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt, count(*) over() as total_amount
from sys_user
limit $1 offset $2
`

type GetSimpleUserListWithPaginationParams struct {
	Limit  int32
	Offset int32
}

type GetSimpleUserListWithPaginationRow struct {
	Uuid            pgtype.UUID
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	GradebookNumber string
	BirthDate       pgtype.Date
	Email           pgtype.Text
	PhoneNumber     pgtype.Text
	StatusUuid      pgtype.UUID
	Password        pgtype.Text
	Salt            pgtype.Text
	TotalAmount     int64
}

func (q *Queries) GetSimpleUserListWithPagination(ctx context.Context, arg GetSimpleUserListWithPaginationParams) ([]GetSimpleUserListWithPaginationRow, error) {
	rows, err := q.db.Query(ctx, getSimpleUserListWithPagination, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimpleUserListWithPaginationRow
	for rows.Next() {
		var i GetSimpleUserListWithPaginationRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.SecondName,
			&i.Patronymic,
			&i.GradebookNumber,
			&i.BirthDate,
			&i.Email,
			&i.PhoneNumber,
			&i.StatusUuid,
			&i.Password,
			&i.Salt,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
select uuid, name, second_name, patronymic, gradebook_number, birth_date, email, phone_number, status_uuid, password, salt from sys_user where email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email pgtype.Text) (SysUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i SysUser
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.SecondName,
		&i.Patronymic,
		&i.GradebookNumber,
		&i.BirthDate,
		&i.Email,
		&i.PhoneNumber,
		&i.StatusUuid,
		&i.Password,
		&i.Salt,
	)
	return i, err
}

const makeUserUnverified = `-- name: MakeUserUnverified :exec
update sys_user set status_uuid = (select s.uuid from status s where type = 'user_status' and internal_value = 'declined')
`

func (q *Queries) MakeUserUnverified(ctx context.Context) error {
	_, err := q.db.Exec(ctx, makeUserUnverified)
	return err
}

const makeUserVerified = `-- name: MakeUserVerified :exec
update sys_user set status_uuid = (select s.uuid from status s where type = 'user_status' and internal_value = 'approved')
`

func (q *Queries) MakeUserVerified(ctx context.Context) error {
	_, err := q.db.Exec(ctx, makeUserVerified)
	return err
}

const updateUserInfoWithGradeBook = `-- name: UpdateUserInfoWithGradeBook :exec
update sys_user
set name             = $1,
    second_name      = $2,
    patronymic       = $3,
    birth_date       = $4,
    phone_number     = $5,
    email            = $6,
    gradebook_number = $7,
    status_uuid      = (select status.uuid from status where internal_value = 'unapproved' and type = 'user_status')
where sys_user.uuid = $8
`

type UpdateUserInfoWithGradeBookParams struct {
	Name            string
	SecondName      string
	Patronymic      pgtype.Text
	BirthDate       pgtype.Date
	PhoneNumber     pgtype.Text
	Email           pgtype.Text
	GradebookNumber string
	Uuid            pgtype.UUID
}

func (q *Queries) UpdateUserInfoWithGradeBook(ctx context.Context, arg UpdateUserInfoWithGradeBookParams) error {
	_, err := q.db.Exec(ctx, updateUserInfoWithGradeBook,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.BirthDate,
		arg.PhoneNumber,
		arg.Email,
		arg.GradebookNumber,
		arg.Uuid,
	)
	return err
}

const updateUserInfoWithoutGradeBook = `-- name: UpdateUserInfoWithoutGradeBook :exec
update sys_user
set name         = $1,
    second_name  = $2,
    patronymic   = $3,
    birth_date   = $4,
    phone_number = $5,
    email        = $6
where uuid = $7
`

type UpdateUserInfoWithoutGradeBookParams struct {
	Name        string
	SecondName  string
	Patronymic  pgtype.Text
	BirthDate   pgtype.Date
	PhoneNumber pgtype.Text
	Email       pgtype.Text
	Uuid        pgtype.UUID
}

func (q *Queries) UpdateUserInfoWithoutGradeBook(ctx context.Context, arg UpdateUserInfoWithoutGradeBookParams) error {
	_, err := q.db.Exec(ctx, updateUserInfoWithoutGradeBook,
		arg.Name,
		arg.SecondName,
		arg.Patronymic,
		arg.BirthDate,
		arg.PhoneNumber,
		arg.Email,
		arg.Uuid,
	)
	return err
}
